---
layout: blog 
android: true 
istop: true 
title: "okhttp核心流程分析" 
background-image: https://ws1.sinaimg.cn/large/006tNc79gy1frlmbn9iw5j31e00x07cj.jpg
date:  2018-05-23 
category: Android 
tags: 
- Android 
---



## 简单使用

```
Request request = new Request.Builder().url("http://www.baidu.com").get().build();

Call call = client.newCall(request);
call.enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {
        System.out.println("Fail");
    }

    @Override
    public void onResponse(Call call, Response response) throws IOException {
        System.out.println(response.body().string());
    }
});
```

**call.enqueue方法**会调用dispatch的enqueue方法。

```
synchronized void enqueue(AsyncCall call) {
  if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
    runningAsyncCalls.add(call);
    executorService().execute(call);
  } else {
    readyAsyncCalls.add(call);
  }
```

## dispatch分发请求

dispatch分发请求。

```
/** Executes calls. Created lazily. */
private @Nullable ExecutorService executorService;

/** Ready async calls in the order they'll be run. */
private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();

/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();

/** Running synchronous calls. Includes canceled calls that haven't finished yet. */
private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
```

dispatch主要维护以上几个队列，将每个请求添加到队列/从队列中移除。

队列中的请求通过线程池**executorService**来执行。

最后会调用到**AsyncCall**的execute()方法中，

```
@Override protected void execute() {
  boolean signalledCallback = false;
  try {
    Response response = getResponseWithInterceptorChain();
    if (retryAndFollowUpInterceptor.isCanceled()) {
      signalledCallback = true;
      responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
    } else {
      signalledCallback = true;
      responseCallback.onResponse(RealCall.this, response);
    }
  } catch (IOException e) {
    if (signalledCallback) {
      // Do not signal the callback twice!
      Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
    } else {
      eventListener.callFailed(RealCall.this, e);
      responseCallback.onFailure(RealCall.this, e);
    }
  } finally {
    client.dispatcher().finished(this);
  }
}
```

最后**getResponseWithInterceptorChain();**调用一系列拦截器完成网络请求。

## 拦截器

```
Response getResponseWithInterceptorChain() throws IOException {
  // Build a full stack of interceptors.
  List<Interceptor> interceptors = new ArrayList<>();
  interceptors.addAll(client.interceptors());
  interceptors.add(retryAndFollowUpInterceptor);
  interceptors.add(new BridgeInterceptor(client.cookieJar()));
  interceptors.add(new CacheInterceptor(client.internalCache()));
  interceptors.add(new ConnectInterceptor(client));
  if (!forWebSocket) {
    interceptors.addAll(client.networkInterceptors());
  }
  interceptors.add(new CallServerInterceptor(forWebSocket));

  Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
      originalRequest, this, eventListener, client.connectTimeoutMillis(),
      client.readTimeoutMillis(), client.writeTimeoutMillis());

  return chain.proceed(originalRequest);
}
```

**chain.proceed()**方法中调用**Response response = interceptor.intercept(next);**处理拦截器逻辑和调用下一个proceed()。

依次循环，完成一次网络情况，并返回response。

### Application Interception

应用拦截器，是okhttp最先调用的拦截器，即上面代码中的**client.interceptors()**。

### Network Interception

网络拦截器，最终网络请求前执行的拦截器，即上面代码中的**client.networkInterceptors()**。

### okhttp自带拦截器

#### RetryAndFollowUpInterceptor

重定向拦截器。

#### BridgeInterceptor

桥接拦截器，主要用来添加头部等信息。

#### CacheInterceptor

缓存拦截器，主要用来添加/读取缓存。

#### ConnectInterceptor

连接拦截器。

#### CallServerInterceptor

请求拦截器。

## 线程池

### ConnectionPool

线程池维护请求队列。

管理所有客户端和服务端的连接，实现连接复用。








---
layout: blog 
android: true 
istop: true 
title: "okhttp核心流程分析" 
background-image: https://ws1.sinaimg.cn/large/006tNc79gy1frlmbn9iw5j31e00x07cj.jpg
date:  2018-05-23 
category: Android 
tags: 
- Android 
---



## 简单使用

```
Request request = new Request.Builder().url("http://www.baidu.com").get().build();

Call call = client.newCall(request);
call.enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {
        System.out.println("Fail");
    }

    @Override
    public void onResponse(Call call, Response response) throws IOException {
        System.out.println(response.body().string());
    }
});
```

**call.enqueue方法**会调用dispatch的enqueue方法。

```
synchronized void enqueue(AsyncCall call) {
  if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
    runningAsyncCalls.add(call);
    executorService().execute(call);
  } else {
    readyAsyncCalls.add(call);
  }
```

## dispatch分发请求

dispatch分发请求。

```
/** Executes calls. Created lazily. */
private @Nullable ExecutorService executorService;

/** Ready async calls in the order they'll be run. */
private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();

/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();

/** Running synchronous calls. Includes canceled calls that haven't finished yet. */
private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
```

dispatch主要维护以上几个队列，将每个请求添加到队列/从队列中移除。

队列中的请求通过线程池**executorService**来执行。

最后会调用到**AsyncCall**的execute()方法中，

```
@Override protected void execute() {
  boolean signalledCallback = false;
  try {
    Response response = getResponseWithInterceptorChain();
    if (retryAndFollowUpInterceptor.isCanceled()) {
      signalledCallback = true;
      responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
    } else {
      signalledCallback = true;
      responseCallback.onResponse(RealCall.this, response);
    }
  } catch (IOException e) {
    if (signalledCallback) {
      // Do not signal the callback twice!
      Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
    } else {
      eventListener.callFailed(RealCall.this, e);
      responseCallback.onFailure(RealCall.this, e);
    }
  } finally {
    client.dispatcher().finished(this);
  }
}
```

最后**getResponseWithInterceptorChain();**调用一系列拦截器完成网络请求。

## 拦截器

```
Response getResponseWithInterceptorChain() throws IOException {
  // Build a full stack of interceptors.
  List<Interceptor> interceptors = new ArrayList<>();
  interceptors.addAll(client.interceptors());
  interceptors.add(retryAndFollowUpInterceptor);
  interceptors.add(new BridgeInterceptor(client.cookieJar()));
  interceptors.add(new CacheInterceptor(client.internalCache()));
  interceptors.add(new ConnectInterceptor(client));
  if (!forWebSocket) {
    interceptors.addAll(client.networkInterceptors());
  }
  interceptors.add(new CallServerInterceptor(forWebSocket));

  Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
      originalRequest, this, eventListener, client.connectTimeoutMillis(),
      client.readTimeoutMillis(), client.writeTimeoutMillis());

  return chain.proceed(originalRequest);
}
```

**chain.proceed()**方法中调用**Response response = interceptor.intercept(next);**处理拦截器逻辑和调用下一个proceed()。

依次循环，完成一次网络情况，并返回response。

### Application Interception

应用拦截器，是okhttp最先调用的拦截器，即上面代码中的**client.interceptors()**。

### Network Interception

网络拦截器，最终网络请求前执行的拦截器，即上面代码中的**client.networkInterceptors()**。

### okhttp自带拦截器

#### RetryAndFollowUpInterceptor

重试和重定向拦截器。

另外，该拦截器会创建一个streamAllocation对象，该对象会在ConnectInterceptor中使用。

```
streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()),
    call, eventListener, callStackTrace);
```

#### BridgeInterceptor

桥接拦截器，主要用来添加请求头部等信息。

#### CacheInterceptor

缓存拦截器，主要用来添加/读取请求缓存，包括head和body。

#### ConnectInterceptor

连接拦截器。

首先会获取stramAllocation对象实例，该对象在RetryAndFollowUpIntercepter拦截器中创建。

```
HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);
RealConnection connection = streamAllocation.connection();
```

以上为该拦截器最重要的两行代码，先来看第一行：

```
public HttpCodec newStream(
    OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
  int connectTimeout = chain.connectTimeoutMillis();
  int readTimeout = chain.readTimeoutMillis();
  int writeTimeout = chain.writeTimeoutMillis();
  boolean connectionRetryEnabled = client.retryOnConnectionFailure();

  try {
    RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
        writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
    HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);

    synchronized (connectionPool) {
      codec = resultCodec;
      return resultCodec;
    }
  } catch (IOException e) {
    throw new RouteException(e);
  }
}
```

newStream方法中会获取一个RealConnection对象，并对该对象进行编码后返回。

```
RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
    writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
    HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);
```

findHealthyConnection方法又回调用findConnection方法，由方法注释可知该方法会先从connectionPool检查是否有可复用的Connection，如果存在则复用，不存在则创建一个。

```
/**
 * Returns a connection to host a new stream. This prefers the existing connection if it exists,
 * then the pool, finally building a new connection.
 */
private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
    boolean connectionRetryEnabled) throws IOException {
  boolean foundPooledConnection = false;
  RealConnection result = null;
  Route selectedRoute = null;
  Connection releasedConnection;
  Socket toClose;
  synchronized (connectionPool) {
  	/**
  	** 省略一些代码，主要是检测异常及connectionPool中是否有可复用的Connection
  	**/
    if (result != null) {
      // If we found an already-allocated or pooled connection, we're done.
      return result;
    }

 	/**
 	** 如果没有可复用的Connection，则创建一个
 	**/
    if (!foundPooledConnection) {
      if (selectedRoute == null) {
        selectedRoute = routeSelection.next();
      }

      // Create a connection and assign it to this allocation immediately. This makes it possible
      // for an asynchronous cancel() to interrupt the handshake we're about to do.
      route = selectedRoute;
      refusedStreamCount = 0;
      result = new RealConnection(connectionPool, selectedRoute);
      acquire(result, false);
    }

	/**
	** RealConnection的connect方法连接服务器
	**/
  // Do TCP + TLS handshakes. This is a blocking operation.
  result.connect(
      connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);
  routeDatabase().connected(result.route());

	/**
	***省略一些代码
	**/

  return result;
}
```

#### CallServerInterceptor

请求拦截器，真正发起网络请求，并获得Response。

## 线程池

### ConnectionPool

线程池维护请求队列。

管理所有客户端和服务端的连接，实现连接复用。








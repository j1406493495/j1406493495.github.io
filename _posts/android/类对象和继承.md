# 类、对象和继承

---

`Kotlin` 类系列课程开课了。。。

`Kotlin` 作为一种[面向对象程序设计](https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/24792?fr=aladdin)，类是不可缺少的一部分，相对于 `Java` 中的类，`Kotlin` 支持一些新的特性，使用起来更加丝滑顺手，各位客官系好安全带，魔毯开起来。。。

## 什么是类

---

`Kotlin` 中使用 **`class`** 关键字声明类。

```kotlin
class Test(var name) {}
```

Kotlin 中的类由**类名**" Test "、**类头**" (var name) "、**类体**" {} "组成。

一个类可以没有类头和类体。

```Kotlin
class Test2
```

> **`Java` 对比**
>
> ```java
> public class Test{}
> ```
>
> - `Java` 中的类没有类头
> - `Kotlin` 中的类默认添加了 `final` 关键字，不可继承；`Kotlin` 中的类若想被继承，需要添加 **`open` 关键字**（详见继承章节）

### 对象

[对象](https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1/2331271#viewPageContent)，可简单的理解为**类的实例**。

> 有一个类名 "Dog"，"Dog" 是一个抽象的概念，泛指狗这种动物。
>
> 而当我说我养了一只 "哈士奇" 时，"哈士奇" 即为 "Dog" 类的实例对象，特指我养的一只名为 "哈士奇" 的狗。

Kotlin 中创建对象的方式很简单，

```Kotlin
//声明一个类 "Dog"
class Dog(var name) {}
//创建实例 "哈士奇"
val Dog husky = Dog("husky")
```

> **Java 对比**
>
> ```java
> Dog dog = new Dog();
> ```
>
> - `Kotlin` 创建对象无需 `new` 关键字

## 可见性修饰符

---

### public

默认可见性修饰符，表示声明随处可见。

> 默认可见性修饰符即为不添加任何修饰符关键词时的场景。

### private

声明只在类内部可见。

*注意：`Kotlin` 的外部类不能访问嵌套类的 `private` 成员。* Show me the code。。。（外部类、嵌套类请看下文）

![](https://ws2.sinaimg.cn/large/006tNc79ly1fzr8gdx9jbj31760cc3zj.jpg)

`AndroidStudio` 编译器直接放了一个大招。。。

### protected

该可见性在 `private` 可见性的基础上，添加了子类可见。

`protected` 不适用于顶层声明，代码见真招；`AndroidStudio` 编译器提示错误。

![](https://ws1.sinaimg.cn/large/006tNc79ly1fzr8iiy1aoj313q04qwf4.jpg)

### internal

声明在模块内可见，该声明为 `Kotlin` 独有，`Java` 中不存在该可见性。

*模块：`AndroidStudio` 中 `File->New->New Module` 即为新建的一个模块。*

> **Java 对比**
>
> - Java 中的默认可见性修饰符为包内可见
> - internal 关键字为 Kotlin 特有

**局部变量、函数和类不能有可见性修饰符。**

## 构造函数

---

`Kotlin` 中一个类可以有一个**主构造函数**和**多个次构造函数**。

### 主构造函数

主构造函数是类头的一部分。

```Kotlin
class People constructor(var name: String) {}
```

如果不存在**注解**和**可见性修饰符**，`constructor` 关键字可以忽略。

```Kotlin
//以下两种情况 constructor 关键字不可忽略
class People private constructor(var name: String){}
class People @Inject constructor(var name: String){}
```

主构造函数中声明的变量可在类中使用，上述代码中 name 变量可作为 People 类的属性使用。

主构造函数的初始化需在 `init` 关键词声明的代码段中进行，

```kotlin
//省略了 constructor 关键字
class People(var name: String) {
    val firstName: String? = "hello === ".also(::println)
    
    init {
        name = "Woong === "
        println("init $name")
    }
    
    val lastName: String? = "world === ".also(::println)
}
```

上述代码执行后打印日志：

```Kotlin
I/System.out: hello === 
I/System.out: init Woong = 
I/System.out: world === 
```

可见在实例初始化期间，`init` 代码段会与属性交织在一起，按照它出现在类体中的顺序执行。

### 次构造函数

`Kotlin` 中有次级构造函数的概念，它们以 `constructor` 关键字作为前缀。

```kotlin
class People(var name: String?) {
    init {
        println("init $name === ")
    }

    //直接委托
    //次级构造函数中声明变量不能用 var 和 val，这些变量不会作为类的属性
    constructor(firstName: String?, lastName: String?) : this("$firstName$lastName") {
        println("$firstName + $lastName === ")
    }
    
    //间接委托
    constructor(firstName: String?, lastName: String?, age: Int?) : this(firstName, lastName) {
        println("$firstName, $lastName, $age === ")
    }
}

var p: People = People("Wo", "ong")
```

如果存在主构造函数，次构造函数必须委托给主构造函数，可以通过**直接委托**和**通过其他次级构造函数间接委托**。

上述代码就是通过 `this` 关键字进行直接委托，执行结果如下：

```Kotlin
I/System.out: init Woong === 
I/System.out: Wo + ong === 
```

可见委托后会**先执行主构造函数的 `init` 初始化，后执行自身的初始化**。

若采用间接委托，执行代码：

```kotlin
var p1: People = People("Wo", "ong", 18)
```

执行结果如下：

```kotlin
I/System.out: init Woong === 
I/System.out: Wo + ong === 
I/System.out: Wo, ong, 18 === 
```

间接委托会逐级调用初始化，直到本身初始化完成。

此外，如果不主动声明构造函数，编译器会生成一个默认不带参数的主构造函数。

> **Java 对比**
>
> - `Java` 中没有主次构造方法，没有 `constructor` 关键字
> - `Java` 中构造方法方法名必须与类名一致

## 属性

---

声明一个属性的完整语法是：

```kotlin
var <propertyName>[: <PropertyType>] [= <property_initializer>]
    [<getter>]
    [<setter>]
```

initializer、getter 和 setter  均可以省略，PropertyType 可以通过 初始器 或者 getter 返回值推断获得。

### getter() 和 setter()

```kotlin
//var num: Int = 4 的实际声明
var num: Int = 4
    get() = field
    set(value) {field = value}

//val 无 setter 函数
val num: Int = 5
	get() = field
```

上述代码显示 getter 和 setter 的默认方式，其中 `field` 为属性本身（详见幕后字段）。

当然，我们可以**自定义 getter 和 setter 函数**。

```Kotlin
//获取到的 num 值永远为20
//执行 num = 1 后，field 的实际值为 2
var num: Int = 4
	get() = 20
	set(value) {field = value * 2}

//通过自定义 getter 判断 size 的值是否为0
val size = 1
val isEmpty: Boolean
    get() = this.size == 0
```

另外通过 setter 可以**更改访问器的可见性**和**添加注解**。

```kotlin
// 此 setter 是私有的并且有默认实现
// 添加 private 修饰后，只能通过添加一个公有函数去修改其属性，如 Java 中的 setXXX。
var setterVisibility: String = "abc"
    private set 

// 用 Inject 注解此 setter
var setterWithAnnotation: Any? = null
    @Inject set 
```

### 幕后字段

在 `Kotlin` 类中不能直接声明字段。

然而，当一个属性需要一个幕后字段时，`Kotlin` 会自动提供。这个幕后字段可以使用`field`标识符在访问器中引用：

```kotlin
var counter = 0 // 注意：这个初始器直接为幕后字段赋值
    set(value) {
        if (value >= 0) field = value
    }
```

`field` 标识符只能用在属性的访问器内。

如果属性至少一个访问器使用默认实现，或者自定义访问器通过 `field` 引用幕后字段，将会为该属性生成一个幕后字段。

例如，下面的情况下， 就没有幕后字段：

```kotlin
val isEmpty: Boolean
    get() = this.size == 0
```

### 幕后属性

我们直接看官方的例子：

```kotlin
private var _table: Map<String, Int>? = null
public val table: Map<String, Int>
    get() {
        if (_table == null) {
            _table = HashMap() // 类型参数已推断出
        }
        return _table ?: throw AssertionError("Set to null by another thread")
    }
```

_table 是私有属性，外部可通过 table 属性访问，且 table 属性添加了空指针检测。

与 `Java` 相比，通过默认 getter 和 setter 访问私有属性会被优化，不会引入函数调用开销。

### 编译期常量

```kotlin
const val CONST_NUM = 5
```

用 `const` 关键字声明的属性称为**编译期常量**，该属性需满足以下要求：

- 位于顶层或者是**object声明**或**companion object**的一个成员
- 以 `String` 或原生类型值初始化
- 没有自定义 getter

### 延迟初始化

当属性需要通过**依赖注入**或者**在单元测试的 setup 方法中**初始化时，可以使用 `lateinit` 关键字让属性延迟初始化。

```kotlin
class People {
    // 声明一个User对象的属性
    lateinit var my : User     
}
```

- 该关键字必须声明在类体中，并且只能是用`var`修饰的属性，并且该属性没有自定义的`setter()`与`getter()`函数。
- 该属性必须是非空的值，并且该属性的类型不能为基本类型。

## 函数

---

请见函数章节。

---

## 继承

---

```kotlin
open class People
class Man : People()
```

类 Man 继承自类 People。

类 Man 称为**派生类**，类 People 称为**基类**。

默认情况下，`Kotlin` 中的类都带有 `final`，即不可继承。添加 `open` 关键字使类可以被继承。

- 派生类中使用 `super` 关键字调用基类的属性和函数。

- 基类的初始化先于派生类。

### Any类

`Kotlin` 中所有的类都继承自 `Any` 类。

```kotlin
//隐式继承自 Any 类
class Test
```

*`Any` 并不是 `Java` 中的 `Object`，它除了 `equals()`、`hashCode()` 与 `toString()` 外没有任何成员。*

### 继承中的构造函数

#### 派生类无主构造函数

```kotlin
class MyView : View {
    //super 方式
    constructor(context: Context) : super(context)
    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int)
        : super(context, attrs, defStyleAttr)
    
    //this 方式
    constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0)
}
```

当派生类中无主构造函数时，派生类的各次构造函数必须使用 `super` 关键字初始化基类型，或者使用 `this` 关键字委托给其他次级构造函数。

不同的次构造函数可以调用基类型的不同的构造函数。

#### 派生类有主构造函数

```kotlin
class MyView(context: Context?, attrs: AttributeSet?, defStyleAttr: Int)
    : View(context, attrs, defStyleAttr) {
    constructor(context: Context?) : this(context,null,0)
    constructor(context: Context?,attrs: AttributeSet?) : this(context,attrs,0)
}
```

当派生类中有主构造函数时，其基类型必须用基类的主构造函数参数初始化。

一般实现基类中参数最多的构造函数，参数少的构造函数则用`this`关键字引用。

### 函数重写

```kotlin
open class People {
    open fun hello() {}
}

class Man : People() {
    override fun hello() {}
    //final override fun hello() {}
}
```

`open` 关键字声明基类的 hello 函数可以被重写，`override` 关键字表示派生类重写了基类的 hello 函数。

派生类中可给 hello 函数添加 `final` 关键字，阻止其派生类重写 hello 方法。

### 属性重写

```kotlin
open class People {
    open val age: Int = 1
}

class Man : People() {
    override var age: Int = 18
        set(value) {field = value * 2}
}
```

属性重写的使用方式和函数重写基本一致，需要注意的是：

*`var` 属性可以覆盖 `val` 属性，反之不行，因为 `val` 不能有 setter，而基类的 `var` 有 setter。*

### 覆盖规则

我们直接看官方例子：

```kotlin
open class A {
    open fun f() { print("A") }
    fun a() { print("a") }
}
//接口相关内容请看下一章节
interface B {
    fun f() { print("B") } // 接口成员默认就是“open”的
    fun b() { print("b") }
}

class C() : A(), B {
    // 编译器要求覆盖 f()：
    override fun f() {
        super<A>.f() // 调用 A.f()
        super<B>.f() // 调用 B.f()
    }
}
```

为了表示采用从哪个超类继承的实现，我们使用 `super<A>` 或者 `super\<B>`的方式选择需要的函数。

> **Java 对比**
>
> - `Java` 中用 `extends` 关键字表示继承
> - `Java` 中无主次构造函数之别造成的继承区别
> - 覆盖规则不同，`Java` 中会把父类的方法当作接口的实现

## 接口

```kotlin
interface 接口名 {}
class 类名 ： 接口名 {
    // 重写的接口函数、属性等
}
```

`Kotlin` 中使用 `interface` 关键字定义接口，类使用 `:` 实现接口，并用 `override` 关键字实现相关的函数和属性。

一个类可以实现一个或者多个接口。

### 接口函数

```kotlin
// 定义接口 Speak
interface Speak {  
    fun sayHello() : String?
    fun sayBye() :  {
        println("Bye")
    }
}
// Human 类实现接口 Speak
class Human : Speak {
    override fun sayHello() : String? {
        println("Hello")
        return "Hello"
    }
}
```

接口中包含结构体的函数在实现类中可以不实现。

### 接口属性

```kotlin
interface Speak {
    val sayA: String? // 抽象属性
    val sayB: String? // 提供访问器实现
        get() = "B"
}

class Human : Speak {
    override val sayA: String?
        get() = "A"
}
```

接口中可以定义**抽象属性**或者**提供访问器实现的属性**。同函数，提供访问器实现的属性在实现类中可以不实现。

*接口中的属性没有幕后字段，即不能使用 `field` 关键字。*

### 接口继承

```kotlin
interface Name {
    val name: String
}

interface EnglishName : Name {
    val firstName: String
    val lastName: String

    override val name: String get() = "$firstName $lastName"
}

class Woman (
    // 不必实现“name”
    override val firstName: String,
    override val lastName: String
) : EnglishName
```

派生接口既可以添加新的成员也可以实现基接口的成员。

### 覆盖规则

接口的覆盖规则和继承一致，直接看官网例子：

```kotlin
interface A {
    fun foo() { print("A") }
    fun bar()
}

interface B {
    fun foo() { print("B") }
    fun bar() { print("bar") }
}

class C : A, B {
    override fun foo() {
        super<A>.foo()
        super<B>.foo()
    }

    override fun bar() {
        super<B>.bar()
    }
}
```

## 类的分别

------

### 内部类

### 嵌套类

### 数据类

### 枚举类

### 密封类

### 接口类

### 抽象类

## object关键字

---

### 对象声明

### 伴生对象

### 对象表达式

## by关键字

---

### 委托类

### 委托属性

## 总结

---









